# 创建型模式

> [!hint] 关注对象的创建过程，使得对象的创建和使用分离
> 

## 单例模式

> [!question] 是什么
> 

确保一个类只有一个实例，并提供一个全局访问点。

> [!question] 为什么需要
> 

例如**数据库连接**、**日志管理器**、**线程池**这样的对象，一般需要保证全局唯一

> [!note] 解决方案
> 

将**默认构造函数设为私有**， 防止其他对象使用单例类的 `new`运算符。

新建一个静态构建方法作为构造函数，该静态构造函会创建并返回唯一的一个对象

> [!question] 与全局变量的区别
> 

- **单例模式** 是一种设计模式，提供了一种控制类实例化的机制，具有良好的封装性和可维护性，适用于需要全局唯一实例的复杂场景。
- **全局变量** 是一种编程方式，简单直接，但缺乏封装性和控制，适用于简单的全局状态管理。

**单例模式**可以延迟初始化，可以保证线程安全
**全局变量**立即初始化，多线程环境下会有竞争问题

> [!note] 应用实例
> 

Java Spring中默认情况下将`Bean`的作用域设置为单例，无论何时从Spring中获取同一个Bean，返回的都是同一个实例

---

## 工厂方法模式

> [!question] 是什么
> 

定义一个用于创建对象的接口，但让子类决定实例化哪一个类。

通过工厂来返回一个已经创建好的对象，隐藏对象创建的方式和细节，客户端只需要告诉工厂需要什么对象即可，对象的创建过程在工厂模式内部实现，与客户端无关，解耦了

> [!question] 为什么需要
> 

作一个对比：

没有使用工厂模式：

```JAVA
Object a = new Object1();

Object b = new Object2();
```

创建了`Object1`和`Object2`两个对象

使用了工厂模式：

```JAVA

Factory a_f = new FactoryA();
Factory b_f = new FactoryB();

Object a = a_f.createObject();
Object b = b_f.createObject();

```

看起来好像工厂模式的代码会多一些更加繁琐一些，但是如果`Object1`和`Object2`这两个对象的创建比较复杂并且可能需要修改的情况下，例如如下情况：

```JAVA

Rely r1 = new Rely1();
Rely r2 = new Rely2();
...

// 对象的创建需要多个依赖
Object a = new Object(r1, r2, ....); 
// 对象创建好之后需要预先执行某些操作
a.execu1();
a.execu2();
```

可以看到，这个时候如果还在客户端进行对象的创建就会变得非常的繁琐，且创建过程逻辑上不应该在这里实现

并且，如果这个对象之后需要添加或者删除新的依赖的话，需要在客户端这里修改，并且是任意会创建并使用这个对象的地方都需要修改，整个过程变得异常的繁琐和脏

而此时如果使用了**工厂模式**

那么我们要做的就是在工厂模式里面修改这个对象的创建过程即可，把对象的繁琐创建流程放在工厂里面，这样只需要修改一次，而客户端不需要修改任何代码，逻辑上也是正确的

```JAVA
class FactoryA
{
	...
	Object1 createObject(){
		Rely r1 = new Rely1();
		Rely r2 = new Rely2();
		...
		
		// 对象的创建需要多个依赖
		Object a = new Object(r1, r2, ....); 
		// 对象创建好之后需要预先执行某些操作
		a.execu1();
		a.execu2();
		return a;
	}
}
```

## 原型模式

> [!question] 是什么
> 

**原型模式** 是一种创建型设计模式，它允许你通过**复制现有对象来创建新的对象**，而不是通过常规的构造函数。这种方式的主要好处是可以**在运行时动态地创建对象**，而**无需知道对象的具体类**。

简单来说就是通过克隆现有的对象来创建一个新的对象

> [!question] 为什么需要
> 

**需要频繁创建相似对象** ：当需要创建大量相似的对象时，原型模式可以减少代码重复，提高代码的可维护性。

**对象创建成本高** ：当创建一个对象需要大量资源或时间时，可以通过复制现有对象的方式来节省时间和资源。

# 结构型模式

## 适配器模式

> [!question] 是什么
> 

**适配器模式** （Adapter Pattern）是一种结构型设计模式，它允许不兼容的接口一起工作

适配器模式通过创建一个**适配器类**，将一个类的接口**转换**成客户端所期望的接口，从而使原本不兼容的类能够协同工作。


> [!question] 为什么需要
> 

适配器模式的主要目的是让两个不兼容的接口能够一起工作。想象一下，有一台旧电视和一台新 DVD 播放器，但旧电视没有 HDMI 接口，只有 RCA 接口。为了让你的新 DVD 播放器能够连接到旧电视上，你需要一个适配器，把 HDMI 信号转换成 RCA 信号。

```JAVA
public class Adapter implements Target {
    private NewSystem newSystem;

    public Adapter(NewSystem newSystem) {
        this.newSystem = newSystem;
    }

    @Override
    public void oldMethod() {
        // 委托调用新系统的方法
        newSystem.newMethod();
    }
}
```

通过在类种实现老类的接口方法，可以让这个新的类提供与原来一样的接口

# 行为型模式

